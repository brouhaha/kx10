#! /usr/bin/perl
#
# Instruction dispatch table generator for kx10, the PDP-10 emulator.
# Copyright (C) 1991, 1992, 1993, 1994, 1995  Stu Grossman
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
#

#
# This program will grovel through the i_ files looking for instruction
# definitions.  From these it will create a dispatch table, and a name table.
#

#for ($i = 0; $i < 01000; $i++) {
#	$iarray[$i] = sprintf("%03o", $i);
#}

# First, scan through the files looking for INST and IO_INST declarations, and collect
# them in $iarray.


@io_ops = ("blki", "datai", "blko", "datao",
	   "cono", "coni", "consz", "conso");

%name_to_code = ("blki", 0, "datai", 1, "blko",  2, "datao", 3,
		 "cono", 4, "coni",  5, "consz", 6, "conso", 7);

@filearray = @ARGV;

$argsep = '\s*,\s*';		# Argument seperator

while(<>) {
	if (/^INST\((.*)\).*$/) {
		($opname, $opcode) = split($argsep, $1);
		$iarray[oct($opcode)] = $opname;
	} elsif (/^IO_INST\((.*)\).*$/) {
		($opname, $devname, $devcode) = split($argsep, $1);
		$tmp = (oct($devcode) << 1) + $name_to_code{$opname};
		$ioarray{$tmp} = "$opname $devname";
	}
}

@defined = grep(!/^[0-7]+/, @iarray);

open(dfile, ">dispatch.c");

# First, print the prolog

print dfile
"#include \"pdp10.h\"
#ifdef comment
This file was automatically generated by gendisp from the following files:
	" .
join("\n	", @filearray) .
"
#endif /* comment */

";

# generate the extern table

print dfile "extern void ";

print dfile "i_unimp(),i_io_unimp(),i_luuo(),i_uuo(),";

$comma = "";
foreach $inst (@defined) {
	if (defined($inst)) {
		print dfile "${comma}i_${inst}()";
		$comma = ",";
	}
}
foreach $inst (%ioarray) {
	($op, $dev) = split(/ /, $inst);
	print dfile ",i_${op}_${dev}()";
}
print dfile ";\n\n";

# Generate the uuo forward refs

print dfile "static void ";

$comma = "";
for ($i = 0; $i <= 0100; $i++) {
	$i_oct = sprintf("%o", $i);

	print dfile "${comma}i_uuo${i_oct}()";
	$comma = ",";
}
print dfile ",i_uuo104 ();\n\n";

# Generate the forward ref table for the I/O dispatch routines

print dfile "extern void ";

$comma = "";
for($i = 0700; $i < 01000; $i++) {
	$i_oct = sprintf("%o", $i);
	print dfile "${comma}i_io${i_oct}()";
	$comma = ",";
}
print dfile ";\n\n";

# Now, generate the dispatch vector

$comma = "";
print dfile "void (*opdisp[])() = {\n";
for($i = 0; $i < 01000; $i++) {
	$i_oct = sprintf("%o", $i);
	if ($iarray[$i] ne "") {
		$inst = "i_" . $iarray[$i];
		$imp_count++;
	} else {
	    if ($i >= 1 && $i <= 037) {
		$inst = "i_uuo$i_oct";
		$imp_count++;
	    } elsif ($i == 0
		     || ($i >= 040 && $i <= 0100)
		     || $i == 0104) {
		$inst = "i_uuo$i_oct";
		$imp_count++;
	    } elsif (($i >= 0700)) {
		$inst = "i_io$i_oct";
		$imp_count++;
	    } else {
		$inst = "i_unimp";
		$unimp_count++;
	    }
	}
	$tabs = "\t\t\t";
	$tabs =  "\t\t" if (length($inst) >= 8);
	$inst = "$inst$tabs/* $i_oct */";
	print dfile "$comma$inst";
	$comma = ",\n";
}

print dfile "};\n\n";

# uuo and luuo stubs

for($i = 0; $i <= 0100; $i++) {
	$i_oct = sprintf("%o", $i);

	if ($i >= 1 && $i <= 037) {
		$l = l;
	} else {
		$l = "";
	}

	print dfile "static
INST (uuo${i_oct}, 0${i_oct})
{
  i_${l}uuo (0${i_oct}, ac, ea);
}

";
}

print dfile "static
INST (uuo104, 0104)
{
  i_uuo (0104, ac, ea);
}

";

# Generate the second level I/O dispatch routines.  Basically, all
# that these do is restore the opcode and call i_io().

#for($i = 0700; $i <= 0777; $i++) {
#	$i_oct = sprintf("%o", $i);
#
#	print dfile "static
#INST (io$i_oct, 0${i_oct})
#{
#  i_io (0${i_oct}, ac, ea);
#}
#
#";
#}

#print dfile "/* All I/O instructions come through here.  This does the second level dispatch
#   through a switch table.  */
#
#static
#SPECIAL_INST (io, 000)
#{
#  if (!(pcflags & (PC_USER | PC_PUBLIC)) || (pcflags & PC_UIO))
#    (*iodisp[((opcode << 4) | ac) & 01777])(ac, ea);
#  else
#    i_uuo (opcode, ac, ea);
#
#";

# Generate the I/O switch table

#print dfile "  switch ((opcode << 2 | ac) & 01777)\n    {\n";

#for($i = 0; $i <= 01777; $i++) {
#	if ($ioarray{$i} ne "") {
#		($op, $dev) = split(/ /, $ioarray{$i});
#		$inst = "i_${op}_${dev}";
#		if ($i == 0) {
#			$lastdev = $dev;
#		}
#		if ($dev ne $lastdev) {
#			print dfile "\n";
#			$lastdev = $dev;
#		}
#		$tmp = sprintf "    case 0%o<<2|%o: ${inst} (ac, ea); return;", ($i >> 1) & 0774, $i & 07;
#		$tabs = "\t";
#		$tabs = "\t\t" if (length($tmp) < 48);
#		print dfile "${tmp}${tabs}/* $op $dev, */\n";
#	}
#}
#print dfile "    default: i_io_unimp (opcode, ac, ea); return;\n  }\n";
#
#print dfile "}\n\n";

print dfile "char *opnames[] = {";

undef(@xarray);
for($i = 0; $i < 0700; $i++) {
	if ($iarray[$i] ne "") {
		push(@xarray, '"' . $iarray[$i]. '"');
	} else {
	    if ($i >= 1 && $i <= 037) {
		push(@xarray, '"' . "luuo_" . sprintf("%o", $i) . '"');
	    } elsif (($i >= 040 && $i <= 0100)
		     || $i == 0104) {
		push(@xarray, '"' . "uuo_" . sprintf("%o", $i) . '"');
	    } else {
		push(@xarray, '"' . sprintf("%03o", $i) . '"');
	    }
	}
}
print dfile join(', ', @xarray);

print dfile "};\n\n" ;

close(dfile);

print "[There are $imp_count implemented instructions, and $unimp_count unimplimented instructions.]\n"
